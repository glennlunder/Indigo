<html>
<head>
    <title></title>
    <style>
        html, body{
            margin:0;
        }

        button{
            background-color: #4D4D4D;
            color: #CCCCCC;
            border: 1px solid #CCCCCC;
            width: 25%;
            height: 25%;
            margin-top: 20%;
            margin-left: 35%;
            font: 150px Arial, Helvetica, sans-serif;
            -webkit-border-radius: .5em;
            padding-bottom: 2px;
        }

        b {
            color: #C0C0C0;
            font: 25px Arial, Helvetica, sans-serif;
            margin-top: 50%;
            margin-left: 35%;
        }
    </style>

    <script src="js/three.min.js"></script>
    <script src="js/jsRocket.js"></script>
    <script src="js/image.json"></script>

    <script src="js/postprocessing/EffectComposer.js"></script>
    <script src="js/postprocessing/RenderPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>
    <script src="js/postprocessing/MaskPass.js"></script>
    <script src="js/shaders/CopyShader.js"></script>

    <script src="js/shaders/BlinkShader.js"></script>
    <script src="js/shaders/RGBDistort.js"></script>
    <script src="js/shaders/ImageDistort.js"></script>
    <script src="js/shaders/Overlay.js"></script>
</head>
<body>
<script id="vs" type="x-shader/x-vertex">
uniform sampler2D map;

uniform float width;
uniform float height;
uniform float nearClipping, farClipping;

uniform float pointSize;
uniform float zOffset;

varying vec2 vUv;

const float XtoZ = 1.11146; // tan(1.0144686 / 2.0) * 2.0;
const float YtoZ = 0.83359; // tan(0.7898090 / 2.0) * 2.0;

void main() {
    vUv = vec2(position.x / width, position.y / height);

    vec4 color = texture2D( map, vUv );
    float depth = (color.r + color.g + color.b) / 4.0;

    float z = (1.0 - depth) * (farClipping - nearClipping) + nearClipping;

    vec4 pos = vec4((position.x / width - 0.5) * z * XtoZ, (position.y / height - 0.5) * z * YtoZ, - z + zOffset, 1.0);

    gl_PointSize = pointSize;
    gl_Position = projectionMatrix * modelViewMatrix * pos;
}
</script>

<script id="fs" type="x-shader/x-fragment">
    uniform sampler2D map;
    varying vec2 vUv;
    void main() {
        vec4 color = texture2D(map, vUv);

        gl_FragColor = vec4(color.r*5., color.g*5., color.b*5., smoothstep(8000.0, -8000.0, gl_FragCoord.z / gl_FragCoord.w));
    }
</script>

<script type="text/javascript">
//TODO coloring
//TODO fog
//TODO title
    var syncDevice = new JSRocket.SyncDevice();
    var BPM = 160;              // Beats per minute
    var RPB = 4;                // Rows per beat
    var RR = BPM / 60 * RPB;    // Row Rate
    var _row;
    var audio;
    var clearR, clearB, clearG;
    var rotX, rotY, rotZ;
    var cPosX, cPosY, cPosZ;
    var cLookX, cLookY, cLookZ;
    var cShakeSpeed, cShakeAmt;
    var demo = false;
    var vidGeo, vidMesh, vidMat;

    // Shadervars
    var blinkAmount = .0;
    var rgbDistAmt = .0;
    var imgDistAmt = .0,
        imgDistAmt2 = .0,
        imgRollSpeed = .0;

function play(){

}

    //var WIDTH = 1280, HEIGHT = 720;
    var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
    var VIEW_ANGLE = 45, ASPECT = WIDTH / HEIGHT, NEAR = 0.1, FAR = 10000;

    var renderer = new THREE.WebGLRenderer({antialias:true});
    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
    var scene = new THREE.Scene();

    var SEPARATION = 40, AMOUNTX = 50, AMOUNTY = 50;
    var cubes = [], cube;
    var i = 0;
    for (var ix = 0; ix < AMOUNTX; ix ++ )
    {
        for (var iy = 0; iy < AMOUNTY; iy ++ )
        {
            var geometry = new THREE.CubeGeometry( 10, 10, 10 );
            for ( var c = 0; c < geometry.faces.length; c ++ ) geometry.faces[c].color.setHex( Math.random() * 0xffffff );

            cube = cubes[i ++] = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({vertexColors: THREE.FaceColors}));
            cube.position.x = ix * SEPARATION - ((AMOUNTX * SEPARATION ) / 2);
            cube.position.z = iy * SEPARATION - ((AMOUNTY * SEPARATION ) / 2);

            scene.add(cube);
        }
    }

    var ambientLight = new THREE.AmbientLight(0x212223);
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();

    var canvas = document.createElement('canvas');
    canvas.width = 1280;
    canvas.height = 720;
    var context = canvas.getContext('2d');
    context.fillStyle = '#fff'; // CHANGED
    context.font = '34px Arial';
    context.fillText("an", 0, HEIGHT/2);
    context.font = '150px Arial';
    context.fillText("Indigo", 30, HEIGHT/2);
    context.font = '54px Arial';
    context.fillText("production", 440, HEIGHT/2);
    var amap = new THREE.Texture(canvas);
    amap.needsUpdate = true;
    var mat = new THREE.SpriteMaterial({
        map: amap,
        transparent: false,
        useScreenCoordinates: false,
        color: 0xffffff // CHANGED
    });
    var textIntro = new THREE.Sprite(mat);
    textIntro.scale.set( 1, 1, 1 ); // CHANGED
    textIntro.position.set(90, -12, 378);
    scene.add(textIntro);

    var canvas = document.createElement('canvas');
    canvas.width = 1280;
    canvas.height = 720;
    var context = canvas.getContext('2d');
    context.fillStyle = '#fff'; // CHANGED
    context.font = '50px Arial';
    context.fillText("Code & Graphics", 0, HEIGHT/2);
    context.font = '160px Arial';
    context.fillText("JoMs", 0, HEIGHT/100*68);
    var amap = new THREE.Texture(canvas);
    amap.needsUpdate = true;
    var mat = new THREE.SpriteMaterial({
        map: amap,
        transparent: false,
        useScreenCoordinates: false,
        color: 0xffffff // CHANGED
    });
    var textJoMs = new THREE.Sprite(mat);
    textJoMs.scale.set( 1, 1, 1 ); // CHANGED
    textJoMs.position.set(-27, 0, 44);
    scene.add(textJoMs);


    var canvas = document.createElement('canvas');
    canvas.width = 1280;
    canvas.height = 720;
    var context = canvas.getContext('2d');
    context.fillStyle = '#fff'; // CHANGED
    context.font = '50px Arial';
    context.fillText("Music", 0, HEIGHT/100*10);
    context.font = '160px Arial';
    context.fillText("Kepler", 0, HEIGHT/100*28);
    var amap = new THREE.Texture(canvas);
    amap.needsUpdate = true;
    var mat = new THREE.SpriteMaterial({
        map: amap,
        transparent: false,
        useScreenCoordinates: false,
        color: 0xffffff // CHANGED
    });
    var textKepler = new THREE.Sprite(mat);
    textKepler.scale.set( 1, 1, 1 ); // CHANGED
    textKepler.position.set(-27, 0, 44);
    scene.add(textKepler);

    init();
    function init(){
        prepareScene();
        prepareSync();
    }

    function prepareScene(){
        scene.add(camera);
        scene.add(ambientLight);
        scene.add(directionalLight);
        renderer.setSize(WIDTH, HEIGHT);
        document.body.appendChild(renderer.domElement);

        RGBdistortPass = new THREE.ShaderPass(THREE.RGBDistortShader);
        ImagedistortPass = new THREE.ShaderPass(THREE.ImagedistortShader);
        overlay = new THREE.ShaderPass(THREE.OverlayShader);
        blink = new THREE.ShaderPass(THREE.BlinkShader);
        renderPass = new THREE.RenderPass(scene, camera);
        copyPass = new THREE.ShaderPass(THREE.CopyShader);
        composer = new THREE.EffectComposer(renderer);

        composer.addPass(renderPass);
        composer.addPass(ImagedistortPass);
        composer.addPass(RGBdistortPass);
        composer.addPass(blink);
        composer.addPass(overlay);
        composer.addPass(copyPass);
        copyPass.renderToScreen = true;
    }

    function prepareSync(){
        syncDevice.on('ready', onSyncReady);
        syncDevice.on('update', onSyncUpdate);
        syncDevice.on('play', onPlay);
        syncDevice.on('pause', onPause);

        if (demo) {
            syncDevice.setConfig({'rocketXML':'main.rocket'});
            syncDevice.init("demo");
        } else {
            syncDevice.init();
        }
    }

    function onSyncReady(){
        clearR = syncDevice.getTrack('clearR');
        clearG = syncDevice.getTrack('clearG');
        clearB = syncDevice.getTrack('clearB');
        blinkAmount = syncDevice.getTrack('blinkAmt');
        rgbDistAmt = syncDevice.getTrack('rgbDistAmt');
        imgDistAmt = syncDevice.getTrack('imgDistAmt');
        imgDistAmt2 = syncDevice.getTrack('imgDistAmt2');
        imgRollSpeed = syncDevice.getTrack('imgRoll');
        rotX = syncDevice.getTrack('rotX');
        rotY = syncDevice.getTrack('rotY');
        rotZ = syncDevice.getTrack('rotZ');
        cPosX = syncDevice.getTrack('cPosX');
        cPosY = syncDevice.getTrack('cPosY');
        cPosZ = syncDevice.getTrack('cPosZ');
        cLookX = syncDevice.getTrack('cLookX');
        cLookY = syncDevice.getTrack('cLookY');
        cLookZ = syncDevice.getTrack('cLookZ');
        cShakeAmt = syncDevice.getTrack('cShakeAmt');
        cShakeSpeed = syncDevice.getTrack('cShakeSpeed');
        prepareAudio();
    }

    function prepareAudio(){
        audio = new Audio();
        audio.src = "sound/Kepler - Sursild TG2013 Demo[gÃ¥ hjem og v.ogg";
        audio.load();
        audio.preload = true;
        audio.addEventListener('canplay', onAudioReady);
    }

    function onAudioReady(){
        if(!demo){
            audio.pause();
            audio.currentTime = _row / RR;
        } else {
            render();
            audio.play();
        }
    }

    function onSyncUpdate(row) {
        if (!isNaN(row)) {
            _row = row;
        }
        render();
    }


    function onPlay(){
        audio.currentTime = _row / RR;
        audio.play();
        render();
    }

    function onPause(){
        _row = audio.currentTime * RR;
        window.cancelAnimationFrame(render, document);
        audio.pause();
    }

    /***
     * @param t _row/current row
     * @param a Current position
     * @param b Final position
     * @returns {number}
     */
    function lerp(t, a, b){
        return a + t * (b - a);
    }


    var particles;
    function createParticles(){
        var geometry = new THREE.Geometry();
        var material = new THREE.ParticleBasicMaterial({size: 1});
        var i = 0;
        for (var a = 0; a < image.length; a++)
        {
            for (var b = 0; b < image[a].length; b++)
            {
                if (image[a][b].length > 0)
                {
                    var vertex = new THREE.Vector3(0,0,0);
                    vertex.x = a%50;
                    vertex.y = b%50;
                    geometry.vertices.push(vertex);
                }
            }
        }
        particles = new THREE.ParticleSystem(geometry, material);
        particles.geometry.verticesNeedUpdate = true;
        scene.add(particles);
    }

    var sp = new Array();
    function createSprites(){
        for (var i = 0; i < 4; i++)
        {
            var canvas = document.createElement('canvas');
            canvas.width = 1280;
            canvas.height = 720;
            var context = canvas.getContext('2d');
            context.fillStyle = '#fff'; // CHANGED

            if (i == 0)
            {
                context.font = '34px Arial';
                context.fillText("", 0, HEIGHT/2);
            }
            if (i == 1)
            {
                context.font = '34px Arial';
                context.fillText("an", 0, HEIGHT/2);
                context.font = '150px Arial';
                context.fillText("Indigo", 30, HEIGHT/2);
                context.font = '54px Arial';
                context.fillText("production", 440, HEIGHT/2);
            }

            if (i == 2)
            {
                context.font = '50px Arial';
                context.fillText("Code & Graphics", 0, HEIGHT/2);
                context.font = '160px Arial';
                context.fillText("JoMs", 0, HEIGHT/100*68);
            }

            if (i == 3)
            {
                context.font = '50px Arial';
                context.fillText("Music", 0, HEIGHT/100*10);
                context.font = '160px Arial';
                context.fillText("Kepler", 0, HEIGHT/100*28);
            }
            var amap = new THREE.Texture(canvas);
            amap.needsUpdate = true;
            var mat = new THREE.SpriteMaterial({
                map: amap,
                transparent: false,
                useScreenCoordinates: false,
                color: 0xffffff // CHANGED
            });
            var sprite = new THREE.Sprite(mat);
            sprite.scale.set( 1, 1, 1 ); // CHANGED
            sp[i] = sprite;
        }
    }

    function addVid(){
        video = document.createElement( 'video' );
        video.addEventListener( 'loadedmetadata', function ( event ) {
            texture = new THREE.Texture(video);

            var vidWidth = 614, vidHeight = 466;

            vidGeo = new THREE.Geometry();

            for ( var i = 0, l = vidWidth * vidHeight; i < l; i ++ ) {
                var vertex = new THREE.Vector3();
                vertex.x = ( i % vidWidth );
                vertex.y = Math.floor( i / vidWidth );
                vidGeo.vertices.push( vertex );
            }

            vidMat = new THREE.ShaderMaterial( {
                uniforms: {
                    "map": { type: "t", value: texture },
                    "width": { type: "f", value: vidWidth },
                    "height": { type: "f", value: vidHeight },
                    "nearClipping": { type: "f", value: 850 },
                    "farClipping": { type: "f", value: 4000 },

                    "pointSize": { type: "f", value: 2 },
                    "zOffset": { type: "f", value: 1000 }
                },
                vertexShader: document.getElementById( 'vs' ).textContent,
                fragmentShader: document.getElementById( 'fs' ).textContent,
                depthTest: false, depthWrite: false,
                transparent: true
            } );

            vidMesh = new THREE.ParticleSystem(vidGeo, vidMat);
            vidMesh.position.x = 0;
            vidMesh.position.y = 0;
            scene.add(vidMesh);

            setInterval( function () {
                if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
                    texture.needsUpdate = true;
                }
            }, 1000 / 30 );
        }, false );
        video.src = 'gfx/video/Demo.mp4';
        video.play();
    }

    var particleStarted = false;

    function render(){
        if(audio.paused === false) {
            _row = audio.currentTime * RR;
            syncDevice.update(_row);
        }

        var color = new THREE.Color()
        color.setRGB((clearR.getValue(_row) || 0) / 255, (clearG.getValue(_row) || 0) / 255, (clearB.getValue(_row) || 0) / 255);
        renderer.setClearColor(color);

        // Thanks kusma!
        var shake_phase = _row * 32 * cShakeSpeed.getValue(_row);
        var camOffsX = Math.sin(shake_phase);
        var camOffsY = Math.cos(shake_phase * 0.9);
        var camOffsZ = Math.sin(shake_phase - 0.5);

        camera.lookAt(scene.position);
        camera.position.x = cPosX.getValue(_row) + (camOffsX * cShakeAmt.getValue(_row));
        camera.position.y = cPosY.getValue(_row) + (camOffsY * cShakeAmt.getValue(_row));
        camera.position.z = cPosZ.getValue(_row) + (camOffsZ * cShakeAmt.getValue(_row));

        if (_row.toFixed() == 416)
        {
            var i = 0;
            for (var ix = 0; ix < AMOUNTX; ix++)
            {
                for (var iy = 0; iy < AMOUNTY; iy++)
                {
                    cube = cubes[i++];
                    scene.remove(cube);
                }
            }
            if (particleStarted == false)
            {
                createParticles();
                particleStarted = true;
            }
        }
        if (_row.toFixed() == 540){
            scene.remove(particles);
            addVid();
        }

        if (_row < 416)
        {
            var i = 0;
            for (var ix = 0; ix < AMOUNTX; ix++)
            {
                for (var iy = 0; iy < AMOUNTY; iy++)
                {
                    cube = cubes[i++];
                    cube.rotation.x = cube.rotation.y = cube.rotation.z = rotY.getValue(_row) * Math.PI / 180;
                    if (_row <= 88){
                        cube.position.y = (Math.sin((ix + (_row * 0.25)) * 0.4) * 50) + (Math.sin((iy + (_row * 0.25)) * 0.4) * 50);
                        if (cube.position.y > 0)
                            cube.scale.x = cube.scale.y = cube.scale.z = Math.abs(cube.position.y / 50);
                        else
                            cube.scale.x = cube.scale.y = cube.scale.z =  0.1;
                    } else {
                        var f = 25;
                        if (_row > 159) f = 50;
                        cube.position.y = (Math.sin((ix * iy + (_row * 0.05)) * 0.3) * f)
                    }
                }
            }
        }

        else if(_row > 416 && _row < 500)
        {
            var l = 0;
            for (var a = 0; a < image.length; a++)
            {
                for (var b = 0; b < image[a].length; b++)
                {
                    var f = image[a][b];
                    if (f.length > 0)
                    {
                        var p = particles.geometry.vertices[l++];
                        p.setX(lerp((_row-416)/(500-416), a%50, a));
                        p.setY(lerp((_row-416)/(500-416), b%50, b));
                    }
                }
            }
            particles.geometry.verticesNeedUpdate = true;
        }

        if (_row >= 224)
        {
            textKepler.position.set(0, 0, 0);
            textJoMs.position.set(0, 0, 0);
        } else {
            textKepler.position.set(-27, 0, 44);
            textJoMs.position.set(-27, 0, 44);
        }

        overlay.uniforms["time"].value = ImagedistortPass.uniforms["time"].value = audio.currentTime;
        blink.uniforms["amount"].value = blinkAmount.getValue(_row) / 100.0; RGBdistortPass.uniforms["rgbAmt"].value = rgbDistAmt.getValue(_row) / 100.0;
        ImagedistortPass.uniforms["distortion"].value = imgDistAmt.getValue(_row);
        ImagedistortPass.uniforms["distortion2"].value = imgDistAmt2.getValue(_row);
        ImagedistortPass.uniforms["rollSpeed"].value = imgRollSpeed.getValue(_row);

        composer.render(0.1);

        if((demo === true)||(audio.paused === false)) window.requestAnimationFrame(render, document); else window.cancelAnimationFrame(render, document);
        WIDTH = window.innerWidth, HEIGHT = window.innerHeight
        renderer.setSize(WIDTH, HEIGHT);
    }
</script>

</body>
</html>