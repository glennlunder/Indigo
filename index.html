<html>
<head>
    <title></title>
    <style>
        html, body{
            margin:0;
        }
    </style>

    <script src="js/three.min.js"></script>
    <script src="js/jsRocket.js"></script>

    <script src="js/postprocessing/EffectComposer.js"></script>
    <script src="js/postprocessing/RenderPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>
    <script src="js/postprocessing/MaskPass.js"></script>
    <script src="js/shaders/CopyShader.js"></script>

    <script src="js/shaders/FilmShader.js"></script>
    <script src="js/shaders/VignetteShader.js"></script>
    <script src="js/shaders/BlinkShader.js"></script>
    <script src="js/shaders/RGBDistort.js"></script>
</head>
<body>

<script type="text/javascript">
    var syncDevice = new JSRocket.SyncDevice();
    var BPM = 160;              // Beats per minute
    var RPB = 4;                // Rows per beat
    var RR = BPM / 60 * RPB;    // Row Rate
    var _row;
    var audio;
    var clearR, clearB, clearG;
    var rotX, rotY, rotZ;
    var cPosX, cPosY, cPosZ;
    var cShakeSpeed, cShakeAmt;
    var demo = false;
    var blinkAmount = .0;
    var rgbDistAmt = .0;

    var WIDTH = 1280, HEIGHT = 720;
    var VIEW_ANGLE = 45, ASPECT = WIDTH / HEIGHT, NEAR = 0.1, FAR = 10000;

    var renderer = new THREE.WebGLRenderer({antialias:true});
    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
    var scene = new THREE.Scene();

    var SEPARATION = 25, AMOUNTX = 50, AMOUNTY = 50;
    var cubes = [], cube;
    var i = 0;
    for (var ix = 0; ix < AMOUNTX; ix ++ )
    {
        for (var iy = 0; iy < AMOUNTY; iy ++ )
        {
            var geometry = new THREE.CubeGeometry( 10, 10, 10 );
            for ( var c = 0; c < geometry.faces.length; c ++ ) geometry.faces[c].color.setHex( Math.random() * 0xffffff );

            cube = cubes[i ++] = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({vertexColors: THREE.FaceColors}));
            cube.position.x = ix * SEPARATION - ((AMOUNTX * SEPARATION ) / 2);
            cube.position.z = iy * SEPARATION - ((AMOUNTY * SEPARATION ) / 2);
            scene.add(cube);
        }
    }

    var ambientLight = new THREE.AmbientLight(0x212223);
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();

    init();
    function init(){
        prepareScene();
        prepareSync();
    }

    function prepareScene(){
        scene.add(camera);
        scene.add(ambientLight);
        scene.add(directionalLight);
        renderer.setSize(WIDTH, HEIGHT);
        document.body.appendChild(renderer.domElement);

        vignettePass = new THREE.ShaderPass( THREE.VignetteShader );
        vignettePass.uniforms["darkness"].value = 1.;

        filmPass = new THREE.ShaderPass( THREE.FilmShader );
        filmPass.uniforms["sCount"].value = 1000;
        filmPass.uniforms["sIntensity"].value = .5;
        filmPass.uniforms["nIntensity"].value = .4;

        blinkPass = new THREE.ShaderPass(THREE.BlinkShader);
        blinkPass.uniforms["amount"].value = .0;

        RGBDistortPass = new THREE.ShaderPass(THREE.RGBDistortShader);

        renderPass = new THREE.RenderPass( scene, camera );
        copyPass = new THREE.ShaderPass( THREE.CopyShader );
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(RGBDistortPass);
        composer.addPass(blinkPass);
        composer.addPass(vignettePass);
        composer.addPass(filmPass);
        composer.addPass(copyPass);
        copyPass.renderToScreen = true;
    }

    function prepareSync(){
        syncDevice.on('ready', onSyncReady);
        syncDevice.on('update', onSyncUpdate);
        syncDevice.on('play', onPlay);
        syncDevice.on('pause', onPause);

        if (demo) {
            syncDevice.setConfig({'rocketXML':'main.rocket'});
            syncDevice.init("demo");
        } else {
            syncDevice.init();
        }
    }

    function onSyncReady(){
        clearR = syncDevice.getTrack('clearR');
        clearG = syncDevice.getTrack('clearG');
        clearB = syncDevice.getTrack('clearB');
        blinkAmount = syncDevice.getTrack('blinkAmt');
        rgbDistAmt = syncDevice.getTrack('rgbDistAmt');
        rotX = syncDevice.getTrack('rotX');
        rotY = syncDevice.getTrack('rotY');
        rotZ = syncDevice.getTrack('rotZ');
        cPosX = syncDevice.getTrack('cPosX');
        cPosY = syncDevice.getTrack('cPosY');
        cPosZ = syncDevice.getTrack('cPosZ');
        cShakeAmt = syncDevice.getTrack('cShakeAmt');
        cShakeSpeed = syncDevice.getTrack('cShakeSpeed');
        prepareAudio();
    }

    function prepareAudio(){
        audio = new Audio();
        audio.src = "sound/Tromlebass 160 BPM [struktur klar].mp3";
        audio.load();
        audio.preload = true;
        audio.addEventListener('canplay', onAudioReady);
    }

    function onAudioReady(){
        if(!demo){
            audio.pause();
            audio.currentTime = _row / RR;
        } else {
            render();
            audio.play();
        }
    }

    function onSyncUpdate(row) {
        if (!isNaN(row)) {
            _row = row;
        }
        render();
    }


    function onPlay(){
        audio.currentTime = _row / RR;
        audio.play();
        render();
    }

    function onPause(){
        _row = audio.currentTime * RR;
        window.cancelAnimationFrame(render, document);
        audio.pause();
    }

    function render(){
        if(audio.paused === false) {
            _row = audio.currentTime * RR;
            syncDevice.update(_row);
        }

        var color = new THREE.Color()
        color.setRGB((clearR.getValue(_row) || 0) / 255,
                (clearG.getValue(_row) || 0) / 255,
                (clearB.getValue(_row) || 0) / 255);
        renderer.setClearColor(color);

        // Thanks kusma!
        var shake_phase = _row * 32 * cShakeSpeed.getValue(_row);
        var camOffsX = Math.sin(shake_phase);
        var camOffsY = Math.cos(shake_phase * 0.9);
        var camOffsZ = Math.sin(shake_phase - 0.5);

        camera.lookAt(scene.position);
        camera.position.x = cPosX.getValue(_row) + (camOffsX * cShakeAmt.getValue(_row));
        camera.position.y = cPosY.getValue(_row) + (camOffsY * cShakeAmt.getValue(_row));
        camera.position.z = cPosZ.getValue(_row) + (camOffsZ * cShakeAmt.getValue(_row));

        var i = 0;
        for ( var ix = 0; ix < AMOUNTX; ix ++ ) {
            for ( var iy = 0; iy < AMOUNTY; iy ++ ) {
                cube = cubes[ i++ ];

                if (_row <= 88){
                    cube.position.y = (Math.sin((ix + (_row * 0.25)) * 0.4) * 50) + (Math.sin((iy + (_row * 0.25)) * 0.4) * 50);
                    if (cube.position.y > 0)
                        cube.scale.x = cube.scale.y = cube.scale.z = Math.abs(cube.position.y / 50);
                    else
                        cube.scale.x = cube.scale.y = cube.scale.z =  0.1;
                } else {
                    cube.position.y = (Math.sin((ix + (_row * 0.075) * Math.sin(iy)) * 0.3) * 50) + (Math.sin((iy + (_row * 0.075) * Math.sin(ix)) * 0.5) * 50);
                        cube.scale.x = cube.scale.y = cube.scale.z = Math.abs(cube.position.y / 50);
                }

                cube.rotation.x = cube.rotation.y = cube.rotation.z = rotY.getValue(_row) * Math.PI / 180;
            }
        }

        filmPass.uniforms["time"].value = audio.currentTime;
        blinkPass.uniforms["amount"].value = blinkAmount.getValue(_row);
        RGBDistortPass.uniforms["amount"].value = rgbDistAmt.getValue(_row);
        camera.lookAt( scene.position );

        composer.render(0.1);
        //renderer.render(scene, camera);

        if((demo === true)  || (audio.paused === false))
            window.requestAnimationFrame(render, document);
        else
            window.cancelAnimationFrame(render, document);
    }
</script>

</body>
</html>