<html>
<head>
    <title></title>
    <style>
        html, body{
            margin:0;
        }
    </style>

    <script src="js/three.min.js"></script>
    <script src="js/jsRocket.js"></script>
    <script src="js/image.json"></script>

    <script src="js/postprocessing/EffectComposer.js"></script>
    <script src="js/postprocessing/RenderPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>
    <script src="js/postprocessing/MaskPass.js"></script>
    <script src="js/shaders/CopyShader.js"></script>

    <script src="js/shaders/BlinkShader.js"></script>
    <script src="js/shaders/RGBDistort.js"></script>
    <script src="js/shaders/ImageDistort.js"></script>
    <script src="js/shaders/Overlay.js"></script>
</head>
<body>

<script type="text/javascript">
    var syncDevice = new JSRocket.SyncDevice();
    var BPM = 160;              // Beats per minute
    var RPB = 4;                // Rows per beat
    var RR = BPM / 60 * RPB;    // Row Rate
    var _row;
    var audio;
    var clearR, clearB, clearG;
    var rotX, rotY, rotZ;
    var cPosX, cPosY, cPosZ;
    var cLookX, cLookY, cLookZ;
    var cShakeSpeed, cShakeAmt;
    var demo = false;

    // Shadervars
    var blinkAmount = .0;
    var rgbDistAmt = .0;
    var imgDistAmt = .0,
        imgDistAmt2 = .0,
        imgRollSpeed = .0;

    var WIDTH = 1280, HEIGHT = 720;
    var VIEW_ANGLE = 45, ASPECT = WIDTH / HEIGHT, NEAR = 0.1, FAR = 10000;

    var renderer = new THREE.WebGLRenderer({antialias:true});
    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
    var scene = new THREE.Scene();

    var SEPARATION = 40, AMOUNTX = 50, AMOUNTY = 50;
    var cubes = [], cube;
    var i = 0;
    var materials, particle, particles = new Array();
    for (var ix = 0; ix < AMOUNTX; ix ++ )
    {
        for (var iy = 0; iy < AMOUNTY; iy ++ )
        {
            var geometry = new THREE.CubeGeometry( 10, 10, 10 );
            for ( var c = 0; c < geometry.faces.length; c ++ ) geometry.faces[c].color.setHex( Math.random() * 0xffffff );

            cube = cubes[i ++] = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({vertexColors: THREE.FaceColors}));
            cube.position.x = ix * SEPARATION - ((AMOUNTX * SEPARATION ) / 2);
            cube.position.z = iy * SEPARATION - ((AMOUNTY * SEPARATION ) / 2);

            scene.add(cube);
        }
    }



    var ambientLight = new THREE.AmbientLight(0x212223);
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();

    init();
    function init(){
        prepareScene();
        prepareSync();
    }

    function prepareScene(){
        scene.fog = new THREE.FogExp2( 0x000000, 0.0007 );
        scene.add(camera);
        scene.add(ambientLight);
        scene.add(directionalLight);
        renderer.setSize(WIDTH, HEIGHT);
        document.body.appendChild(renderer.domElement);

        RGBdistortPass = new THREE.ShaderPass(THREE.RGBDistortShader);
        ImagedistortPass = new THREE.ShaderPass(THREE.ImagedistortShader);
        overlay = new THREE.ShaderPass(THREE.OverlayShader);
        blink = new THREE.ShaderPass(THREE.BlinkShader);

        renderPass = new THREE.RenderPass(scene, camera);
        copyPass = new THREE.ShaderPass(THREE.CopyShader);
        composer = new THREE.EffectComposer(renderer);

        composer.addPass(renderPass);
        composer.addPass(ImagedistortPass);
        composer.addPass(RGBdistortPass);
        composer.addPass(blink);
        composer.addPass(overlay);
        composer.addPass(copyPass);
        copyPass.renderToScreen = true;
    }

    function prepareSync(){
        syncDevice.on('ready', onSyncReady);
        syncDevice.on('update', onSyncUpdate);
        syncDevice.on('play', onPlay);
        syncDevice.on('pause', onPause);

        if (demo) {
            syncDevice.setConfig({'rocketXML':'main.rocket'});
            syncDevice.init("demo");
        } else {
            syncDevice.init();
        }
    }

    function onSyncReady(){
        clearR = syncDevice.getTrack('clearR');
        clearG = syncDevice.getTrack('clearG');
        clearB = syncDevice.getTrack('clearB');
        blinkAmount = syncDevice.getTrack('blinkAmt');
        rgbDistAmt = syncDevice.getTrack('rgbDistAmt');
        imgDistAmt = syncDevice.getTrack('imgDistAmt');
        imgDistAmt2 = syncDevice.getTrack('imgDistAmt2');
        imgRollSpeed = syncDevice.getTrack('imgRoll');
        rotX = syncDevice.getTrack('rotX');
        rotY = syncDevice.getTrack('rotY');
        rotZ = syncDevice.getTrack('rotZ');
        cPosX = syncDevice.getTrack('cPosX');
        cPosY = syncDevice.getTrack('cPosY');
        cPosZ = syncDevice.getTrack('cPosZ');
        cLookX = syncDevice.getTrack('cLookX');
        cLookY = syncDevice.getTrack('cLookY');
        cLookZ = syncDevice.getTrack('cLookZ');
        cShakeAmt = syncDevice.getTrack('cShakeAmt');
        cShakeSpeed = syncDevice.getTrack('cShakeSpeed');
        prepareAudio();
    }

    function prepareAudio(){
        audio = new Audio();
        audio.src = "sound/Kepler - Sursild TG2013 Demo[gÃ¥ hjem og v.ogg";
        audio.load();
        audio.preload = true;
        audio.addEventListener('canplay', onAudioReady);
    }

    function onAudioReady(){
        if(!demo){
            audio.pause();
            audio.currentTime = _row / RR;
        } else {
            render();
            audio.play();
        }
    }

    function onSyncUpdate(row) {
        if (!isNaN(row)) {
            _row = row;
        }
        render();
    }


    function onPlay(){
        audio.currentTime = _row / RR;
        audio.play();
        render();
    }

    function onPause(){
        _row = audio.currentTime * RR;
        window.cancelAnimationFrame(render, document);
        audio.pause();
    }

    /***
     * @param t target / _row
     * @param a Current position
     * @param b Final position
     * @returns {number}
     */
    function lerp(t, a, b){
        return a + t * (b - a);
    }

    var lastLoop = Date.now();
    function render(){
        if(audio.paused === false) {
            _row = audio.currentTime * RR;
            syncDevice.update(_row);
        }

        var color = new THREE.Color()
        color.setRGB((clearR.getValue(_row) || 0) / 255, (clearG.getValue(_row) || 0) / 255, (clearB.getValue(_row) || 0) / 255);
        renderer.setClearColor(color);

        // Thanks kusma!
        var shake_phase = _row * 32 * cShakeSpeed.getValue(_row);
        var camOffsX = Math.sin(shake_phase);
        var camOffsY = Math.cos(shake_phase * 0.9);
        var camOffsZ = Math.sin(shake_phase - 0.5);

        camera.lookAt(scene.position);
        camera.position.x = cPosX.getValue(_row) + (camOffsX * cShakeAmt.getValue(_row));
        camera.position.y = cPosY.getValue(_row) + (camOffsY * cShakeAmt.getValue(_row));
        camera.position.z = cPosZ.getValue(_row) + (camOffsZ * cShakeAmt.getValue(_row));
<<<<<<< HEAD

        var i = 0;
        for (var ix = 0; ix < AMOUNTX; ix++)
=======
        if (_row.toFixed() == 416)
        {
            var i = 0;
            for (var ix = 0; ix < AMOUNTX; ix++)
            {
                for (var iy = 0; iy < AMOUNTY; iy++)
                {
                    cube = cubes[i++];
                    scene.remove(cube);
                }
            }

            geometry = new THREE.Geometry();
            var materials = new THREE.ParticleBasicMaterial({size: 1});
            for (var a = 0; a < 506; a++)
            {
                for (var b = 0; b < 506; b++)
                {
                    if (image[a][b].length > 0)
                    {
                        var vertex = new THREE.Vector3();
                        vertex.x = image[a][b][0];
                        vertex.y = image[a][b][1];
                        vertex.z = image[a][b][2];
                        geometry.vertices.push(vertex);
                        var particle = new THREE.ParticleSystem(geometry, materials);
                        scene.add(particle);
                        b+=1;
                    }
                }
            }
        }

        if (_row < 416)
>>>>>>> 83ac231c348b6d59210e96db9783f816d71fa640
        {
            var i = 0;
            for (var ix = 0; ix < AMOUNTX; ix++)
            {
                for (var iy = 0; iy < AMOUNTY; iy++)
                {
                    cube = cubes[i++];
                    cube.rotation.x = cube.rotation.y = cube.rotation.z = rotY.getValue(_row) * Math.PI / 180;
                    if (_row <= 88){
                        cube.position.y = (Math.sin((ix + (_row * 0.25)) * 0.4) * 50) + (Math.sin((iy + (_row * 0.25)) * 0.4) * 50);
                        if (cube.position.y > 0)
                            cube.scale.x = cube.scale.y = cube.scale.z = Math.abs(cube.position.y / 50);
                        else
                            cube.scale.x = cube.scale.y = cube.scale.z =  0.1;
                    } else {
                        var f = 25;
                        if (_row > 159) f = 50;
                        cube.position.y = (Math.sin((ix * iy + (_row * 0.05)) * 0.3) * f)
                    }
                }
            }
        }
        /*
        else if(_row > 424 && _row < 600)
        {
            var foo = particles.position.z;
            if (particles.position.z <= 20)
            {
                particles.position.z = lerp((_row-424) / (500-424), 0, 20);
            }
        }
        */

        overlay.uniforms["time"].value = ImagedistortPass.uniforms["time"].value = audio.currentTime;
        blink.uniforms["amount"].value = blinkAmount.getValue(_row) / 100.0; RGBdistortPass.uniforms["rgbAmt"].value = rgbDistAmt.getValue(_row) / 100.0;
        ImagedistortPass.uniforms["distortion"].value = imgDistAmt.getValue(_row);
        ImagedistortPass.uniforms["distortion2"].value = imgDistAmt2.getValue(_row);
        ImagedistortPass.uniforms["rollSpeed"].value = imgRollSpeed.getValue(_row);

        composer.render(0.1);

        var fps = 1000/(Date.now() - lastLoop);
        //console.log("FPS: "+ fps.toFixed());
        lastLoop = new Date();
        if((demo === true)||(audio.paused === false)) window.requestAnimationFrame(render, document); else window.cancelAnimationFrame(render, document);
    }
</script>

</body>
</html>